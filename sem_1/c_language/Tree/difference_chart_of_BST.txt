// | Attribute / Tree                |                Binary Search Tree (BST) |                                                 AVL Tree |                                                                                    Red–Black Tree |                                             2–3 Tree (B-Tree order 3) |                                                                    Splay Tree | Expression Tree                                                                       |
// | ------------------------------- | --------------------------------------: | -------------------------------------------------------: | ------------------------------------------------------------------------------------------------: | --------------------------------------------------------------------: | ----------------------------------------------------------------------------: | ------------------------------------------------------------------------------------- |
// | **What it is**                  |   Binary tree where left < node < right |                              BST + strict height balance |                                            BST variant with color rules enforcing approx. balance | Multiway balanced search tree: nodes have 1 or 2 keys (2-node/3-node) |                      Self-adjusting BST: recently accessed nodes move to root | Binary tree representing arithmetic expressions (operators internal, operands leaves) |

// | **Ordered (inorder sorted)?**   |                                     Yes |                                                      Yes |                                                                                               Yes |                                                                   Yes |                                                                           Yes | No (structure encodes expression, inorder may give infix)                             |

// | **Balance guaranteed?**         |                      No (can be skewed) |                                             Yes (strict) |                                                                            Yes (weaker guarantee) |                                               Yes (strongly balanced) |                                                           No (amortized good) | N/A                                                                                   |

// | **Balance condition**           |                                    none |   balance factor (height(left)−height(right)) ∈ {−1,0,1} | color property: root black; red nodes have black children; all root→leaf paths same # black nodes | All leaves same depth; nodes hold 1–2 keys so subtree sizes regulated | No explicit balance; splaying on access keeps frequently used nodes near root | N/A                                                                                   |

// | **Node structure**              |             one key, two child pointers |                     one key, two child pointers + height |                                                           one key, two child pointers + color bit |                           node stores 1 or 2 keys and 2 or 3 children |                                                   one key, two child pointers | operator or operand, left/right pointers                                              |

// | **Max children per node**       |                                       2 |                                                        2 |                                                                                                 2 |                                                                     3 |                                                                             2 | 2                                                                                     |

// | **Height (worst-case)**         |                                    O(n) |                                                 O(log n) |                                                                                          O(log n) |                                                              O(log n) |                                                O(n) worst, amortized O(log n) | O(n) (depends on expression)                                                          |

// | **Height (guarantee)**          |                                    none |                  ≤ 1.44·log₂n (tight bound ≈ 1.44 log n) |                                                                   ≤ 2·log₂(n+1) (constant factor) |                                          O(log n) with small constant |                                                            amortized O(log n) | depends on expression depth                                                           |

// | **Search complexity**           |         O(h) = O(n) worst, O(log n) avg |                                                 O(log n) |                                                                                          O(log n) |                                                              O(log n) |                                                            amortized O(log n) | evaluate/visit all nodes O(n)                                                         |

// | **Insert complexity**           |                                    O(h) |                                     O(log n) (rotations) |                                                                      O(log n) (recolor/rotations) |                                           O(log n) (splits propagate) |                                       amortized O(log n) (splay after insert) | build in O(n) if postfix given                                                        |

// | **Delete complexity**           |                                    O(h) |                                                 O(log n) |                                                                                          O(log n) |                                         O(log n) (merge/redistribute) |                                                            amortized O(log n) | N/A                                                                                   |

// | **Rebalancing operations**      |                                    none |                 single/double rotations (LL, RR, LR, RL) |                                                                            rotations + recoloring |                                         node split/merge (keys shift) |                                  rotations during splay (zig/zig-zig/zig-zag) | none (but tree transforms for simplification possible)                                |

// | **When rebalancing occurs**     |                                   never |                 on every insert/delete to restore factor |                                                     when color rules violated after insert/delete |                       when node overflows/underflows on insert/delete |                      after each access/insert/delete (splay the node to root) | not applicable                                                                        |

// | **Space overhead**              |                                     low |                                    +1 int/field (height) |                                                                           +1 bit per node (color) |                            larger per node (multiple keys & children) |                                                                           low | same as binary tree (operators/operands)                                              |

// | **Good when**                   |  simple ordered data, learning/teaching |                    when strict fast lookups are required |                                                         general-purpose balanced BST in libraries |                         disk/IO bound structures (B-trees), databases |                              access patterns with locality (recent items hot) | parsing, evaluating expressions, compilers                                            |

// | **Pros**                        |               simple, easy to implement |                             fast lookups, strict balance |                                        good amortized constants, simpler than AVL in some inserts |                      excellent for block storage, guaranteed balanced |                                    adapts to access pattern, simple rotations | directly represents computation                                                       |

// | **Cons**                        |                   can degenerate (slow) |                         more rotations than RB sometimes |                                                          more complex color rules to reason about |                                          harder to implement than BST |                                single operation can be expensive (worst O(n)) | not for ordered-key search                                                            |

// | **Duplicates handling**         | commonly allowed (tie-break left/right) |                                    allowed (same as BST) |                                                                                           allowed |                                                               allowed |                                                                       allowed | N/A                                                                                   |

// | **Common libraries / use**      |              teaching, simple sets/maps | rarely standard library; used when strict balance needed |                                                used in many std::map implementations historically |                               used in DB/FS indexes (B-tree variants) |                                           caches, amortized-analysis examples | interpreters, expression evaluation                                                   |

// | **MCQ-friendly invariants**     |                 inorder sorted sequence |                  balance factor of every node ∈ {−1,0,1} |                                   every path has same # black nodes; no red parent with red child |                    internal node keys = 1 or 2; all leaves same depth |                                        splayed node becomes root after access | internal nodes are operators; leaves operands                                         |

// | **Typical interview/MCQ trick** |                 ask worst-case sequence |                      ask # rotations after insert/delete |                                                                         ask black-height property |                                 ask key count per node and leaf depth |                                               ask result of repeated accesses | ask inorder vs prefix/postfix conversion                                              |
